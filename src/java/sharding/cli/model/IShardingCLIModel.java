package sharding.cli.model;

import java.security.KeyPair;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.util.List;
import java.util.Map;

/**
 * A model interface to handle the backend operations of the sharding CLI. Exposes functionality
 * that allows the user to:
 * <ol>
 *   <li>Generate an RSA key pair</li>
 *   <li>Generate key shards using Shamir's secret sharing algorithm</li>
 *   <li>Write all key shards to memory</li>
 *   <li>Encrypt a string using the generated RSA key pair's public key</li>
 *   <li>Decrypt an encrypted byte array using the RSA key pair's private key</li>
 *   <li>Assemble the RSA key obtained from Sharding the generated RSA key from a given set of key
 *   shard indices</li>
 * </ol>
 */
public interface IShardingCLIModel {

  String helpMenu();

  /**
   * Generates an RSA Key Pair of default size--typically 2048 to provide security against
   * brute-force attacks--for Alice and Bob to send secure messages to each other. Alice can use the
   * RSA Key Pair's public key to encrypt and send a message to Bob. Bob can use the RSA Key Pair's
   * private key to decrypt ciphertexts that Alice has sent to him.
   * <p>
   * Suppose Eve is spying on Bob. Eve has access to the public key but not the private key. This
   * means that Eve also has access to the ciphertext that Alice sent. To launch an attack on Bob,
   * Eve must efficiently factor the public key modulus, say N = pq, or equivalently compute the
   * euler totient of N. For a sufficiently large N (on the order of 2^11 or greater), this ensures
   * that Eve cannot mount an efficient attack, securing this key against brute-force attacks.
   * <p>
   * Note that this method should be called first when implementing CLI functionality in the
   * view/controller, as it is nonsensical to shard a key or encrypt when a key is not generated.
   *
   * @return The RSA key pair to be used to encrypt and decrypt messages, and break into shards in
   * the CLI.
   */
  KeyPair RSAKeyGen();

  /**
   * Provides the same functionality as <code>RSAKeyGen()</code> but allows the developer to specify
   * a <code>keySize</code> to publish the key with.
   *
   * @param keySize the size (in bits) of the RSA key pair to be generated, as an integer
   * @return The RSA key pair to be used to encrypt and decrypt messages, and break into shards in
   * the CLI.
   * @throws InsecureRSAKeySizeException if the given key size is not a multiple of 2^11=2048
   */
  KeyPair RSAKeyGen(int keySize)
      throws InsecureRSAKeySizeException;

  /**
   * Uses Shamir's Secret Sharing Algorithm to break a <code>KeyPair</code> (intended to be
   * generated by <code>RSAKeyGen</code>) into <code>n := numTotalShards</code> shards, where the
   * key can be reassembled with a minimum of <code>k := minShardsToCreate</code> shards, where
   * <code>1 <= k <= n</code>
   *
   * @param numTotalShards    n-- the number of shards to break the <code>KeyPair</code> into
   * @param minShardsToCreate k-- the minimum number of Shamir shards required to reassemble the
   *                          original <code>KeyPair</code>
   * @return a <code>Map&lt Integer, byte[]&gt</code> where each key-pair value <code>(i,s)</code>
   * represents the <code>s</code>hard at index <code>i</code>
   */
  Map<Integer, byte[]> shamirShardKey(KeyPair toShard, int numTotalShards, int minShardsToCreate);

  /**
   *
   * @param numTotalShards    n-- the number of shards to break the <code>KeyPair</code> into
   * @param minShardsToCreate k-- the minimum number of Shamir shards required to reassemble the
   * @return a <code>Map&lt Integer, byte[]&gt</code> where each key-pair value <code>(i,s)</code>
   * represents the <code>s</code>hard at index <code>i</code>
   * @throws NoSuchKeyException if the key to shard has not been generated yet
   */
  Map<Integer, byte[]> shamirShardKey(int numTotalShards, int minShardsToCreate)
    throws NoSuchKeyException;

  /**
   * Writes the given <code>PublicKey</code> to a file <code>Public.TXT</code>
   * @param toWrite the <code>PublicKey</code> to write to memory.
   */
  void writePublicKey(PublicKey toWrite);

  /**
   * If a key has been generated, writes it to a file <code>Public.TXT</code>.
   * @throws NoSuchKeyException if no public RSA key has been generated yet.
   */
  void writePublicKey()
    throws NoSuchKeyException;
  /**
   * Writes all of the generated key shards to memory. See implementation comments for
   * implementation details.
   *
   * @param shards a <code>Map&lt Integer, byte[]&gt</code> where each key-pair value
   *               <code>(i,s)</code> represents the <code>s</code>hard at index <code>i</code>
   */
  void writeShards(Map<Integer, byte[]> shards);

  /**
   * If a key has been generated and sharded, writes the private key shards to memory
   * @throws NoSuchKeyException if the key has not been generated and sharded
   */
  void writeShards()
    throws NoSuchKeyException;

  /**
   * Encrypts a given <code>plainText</code> string using the RSA public key <code>encryptWith
   * </code>. Returns a byte array representing the encrypted data in order to decouple the CLI
   * implementation of encrypting data from any specific encoding format.
   * <br>
   * Returning a byte array and taking a string also allows us to easily verify that this method
   * possesses a two-sided inverse <code>decrypt</code> (see below).
   *
   * @param plainText the message to be encrypted
   * @param encryptWith the RSA public key to encrypt <code>plainText</code> with.
   * @return the encrypted ciphertext equivalent of <code>plainText</code> under encryption key
   * <code>encryptWith</code>.
   */
  byte[] encrypt(String plainText, PublicKey encryptWith);

  /**
   * If an RSA key pair has already been generated, this method encrypts a given plaintext using
   * that pair's public key
   *
   * @param plainText the plaintext to encrypt
   * @return the equivalent ciphertext
   * @throws NoSuchKeyException if the key to encrypt with has not been generated.
   */
  byte[] encrypt(String plainText)
    throws NoSuchKeyException;

  /**
   * Decrypts a given byte array representing a ciphertext <code>cipherTextBytes</code>.
   * Returns a string representing the decrypted data in order to decouple the CLI implementation
   * of decrypting data from any specific encoding format of a ciphertext while assuming a
   * human-readable return type.
   * <br>
   * Returning a String and taking a byte array also allows us to easily verify that this method
   * possesses a two-sided inverse <code>encrypt</code>
   * @param cipherTextBytes
   * @param decryptWith
   * @return
   */
  String decrypt(byte[] cipherTextBytes, PrivateKey decryptWith);

  /**
   * If an RSA key pair has already been generated, this method decrypts a given ciphertext using
   * that pair's private key
   *
   * @param cipherTextBytes the ciphertext to decrypt, as a byte array
   * @return the equivalent plaintext
   * @throws NoSuchKeyException if the key to decrypt with has not been generated.
   */
  String decrypt(byte[] cipherTextBytes)
      throws NoSuchKeyException;

  /**
   * Attempts to reassemble a private RSA key from a set of shards, given by their indices when
   * broken into a set of shards using Shamir's Secret Sharing Algorithm (see <code>shamirShardKeys</code>)
   * <br>
   * If possible, returns the private RSA key assembled from the given shards. For example, if
   * a private RSA key <code>key</code> were sharded into 5 parts where 2 can be reassembled to retrieve the key
   * using <code>shamirShardKeys(key, 5, 2)</code>, then we could call
   * <code>assembleShards(i,j)</code>, where <code>0 <= i != j <= 5</code> to reassemble the key.
   * More generally, if we split a private RSA key into <code>n</code> shards where <code>k <= n</code>
   * shards are required to reassemble the key, we could call
   * <code>assembleShards(i₁, i₂, ..., iₖ)</code> to reassemble the key, where all
   * <code>iⱼ</code> are distinct for <code>0 <= j <= n</code>.
   * @param shardIndices
   * @return
   */
  byte[] assembleShards(int... shardIndices);


}
